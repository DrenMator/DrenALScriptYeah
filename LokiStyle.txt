-- СИСТЕМА САМООЧИСТКИ (ТОЧНАЯ КОПИЯ С ПРИМЕРА)
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local plr = Players.LocalPlayer
local SCRIPT_ID = "Moveset_" .. tick() .. "_" .. math.random(1000, 9999)
local activeConnections = {}
local activeObjects = {}
local isAlive = true

local function cleanup()
    if not isAlive then return end
    isAlive = false
    print("[Animation Handler] Self-destructing: new instance detected")
    
    for _, connection in pairs(activeConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    
    for _, object in pairs(activeObjects) do
        if object and object.Parent then
            pcall(function() object:Destroy() end)
        end
    end
    
    activeConnections = {}
    activeObjects = {}
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        local marker = terrain:FindFirstChild("MovesetMarker")
        if marker and marker.Value == SCRIPT_ID then
            marker:Destroy()
        end
    end
end

local function registerConnection(conn)
    if not isAlive then 
        conn:Disconnect()
        return conn 
    end
    table.insert(activeConnections, conn)
    return conn
end

local function registerObject(obj)
    if not isAlive then 
        if obj and obj.Parent then
            obj:Destroy()
        end
        return obj 
    end
    table.insert(activeObjects, obj)
    return obj
end

local function setupMarkerControl()
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if not terrain then return end
    
    for _, child in pairs(terrain:GetChildren()) do
        if child.Name == "MovesetMarker" and child:IsA("StringValue") then
            child:Destroy()
        end
    end
    
    local marker = Instance.new("StringValue")
    marker.Name = "MovesetMarker"
    marker.Value = SCRIPT_ID
    marker.Parent = terrain
    registerObject(marker)
    
    Debris:AddItem(marker, 30)
    
    local connection = terrain.ChildAdded:Connect(function(child)
        if child.Name == "MovesetMarker" and child:IsA("StringValue") then
            if child.Value ~= SCRIPT_ID then
                cleanup()
            end
        end
    end)
    registerConnection(connection)
    
    return marker
end

-- Инициализация системы маркеров
setupMarkerControl()

-- Периодическая проверка маркеров (точная копия с примера)
task.spawn(function()
    while isAlive do
        local terrain = workspace:FindFirstChildOfClass("Terrain")
        if terrain then
            local markers = {}
            for _, child in pairs(terrain:GetChildren()) do
                if child.Name == "MovesetMarker" and child:IsA("StringValue") then
                    table.insert(markers, child)
                end
            end
            
            if #markers > 1 then
                local latestTime = 0
                local latestMarker = nil
                
                for _, marker in pairs(markers) do
                    local markerTime = tonumber(string.match(marker.Value, "Moveset_(%d+%.%d+)_")) or 0
                    if markerTime > latestTime then
                        latestTime = markerTime
                        latestMarker = marker
                    end
                end
                
                if latestMarker and latestMarker.Value ~= SCRIPT_ID then
                    cleanup()
                    break
                end
            end
        end
        task.wait(5)
    end
end)

-- Функция для применения скорости (как в примере)
local function applyVelocity(part, speed, duration)
    if not part or not isAlive or not part.Parent then return nil end
    
    for _, v in pairs(part:GetChildren()) do
        if v:IsA("BodyVelocity") then
            registerObject(v)
            v:Destroy()
        end
    end

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(350000, 0, 350000)
    bv.Velocity = part.CFrame.LookVector * speed
    bv.Parent = part
    registerObject(bv)
    
    task.delay(duration, function()
        if bv and bv.Parent then
            bv:Destroy()
        end
    end)
    
    return bv
end

-- КОНФИГУРАЦИЯ СКИЛЛОВ (КАК В ПРИМЕРЕ)
local CFG = {
    -- Переименование скиллов в интерфейсе
    renames = {
        ["skill1"] = "Speedy Kick", 
        ["skill2"] = "Fastest Dash",
    }
}

-- Функция для переименования скиллов в интерфейсе (как в примере)
local function renameSkillsInHotbar()
    if not isAlive then return end
    
    task.wait(1) -- Ждем загрузки интерфейса
    
    -- Ждем, пока игрок не выйдет из лобби (если есть такая механика)
    repeat task.wait() until plr.Team and plr.Team.Name ~= "lobby"
    task.wait(0.5)
    
    local hotbar = plr.PlayerGui:WaitForChild("Hotbar", 10)
    if hotbar and isAlive then
        local backpack = hotbar:FindFirstChild("Backpack")
        if backpack then
            local hotbarFrame = backpack:FindFirstChild("Hotbar")
            if hotbarFrame then
                for slotName, newName in pairs(CFG.renames) do
                    local skillFrame = hotbarFrame:FindFirstChild(slotName)
                    if skillFrame then
                        local base = skillFrame:FindFirstChild("Base")
                        if base then
                            local toolName = base:FindFirstChild("ToolName")
                            if toolName then
                                toolName.Text = newName
                                print("[Skill Renamer] Renamed " .. slotName .. " to: " .. newName)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- СОБСТВЕННО СКРИПТ ДЛЯ АНИМАЦИЙ
local chigiri = ReplicatedStorage.Resources.chigiri
local KickSound = chigiri:FindFirstChild("Mach kick kick")
local KickAnim = chigiri.MachKick
local DashSound = chigiri.Blitz
local DashAnim = chigiri.BlitzAnim
local IsThisOk = ReplicatedStorage.Resources.isthisok
-- Функция для воспроизведения звуков
local function sfx(sound, part, volume)
    if not isAlive then return nil end
    
    local s = sound:Clone()
    s.Parent = part
    s.Volume = volume or 1
    s:Play()
    
    local soundLength = s.TimeLength
    Debris:AddItem(s, soundLength + 15)
    registerObject(s)
    
    return s
end

-- Функция конвертации ID
local function convert(id)
    return "rbxassetid://" .. id
end

-- Таблица обработчиков анимаций
local animationHandlers = {
    ["131229402549770"] = {
        name = "KickDaBOLL",
        handler = function(character)
            if not isAlive then return end
            -- Воспроизводим звук
            sfx(KickSound, game.SoundService, 10)

            -- Загружаем и воспроизводим анимацию
            local anim = character.Humanoid:LoadAnimation(KickAnim)
            anim:Play()
            registerObject(anim)
            
            -- Возвращаем кулдаун в секундах
            return 6
        end
    },
    ["107639724047550"] = {
        name = "Awakening",
        handler = function(character)
            if not isAlive then return end
            
            -- Воспроизводим звук
            sfx(IsThisOk, game.SoundService, 10)

            -- Возвращаем кулдаун в секундах
            return 20
        end
    },
    ["82240286756891"] = {
        name = "Dash",
        handler = function(character)
            if not isAlive then return end
            
            -- Воспроизводим звук
            sfx(DashSound, game.SoundService, 10)
            
            -- Загружаем и воспроизводим анимацию
            local anim = character.Humanoid:LoadAnimation(DashAnim)
            anim:Play()
            
            -- Применяем скорость
            task.wait(0.55)
            applyVelocity(character.HumanoidRootPart, 500, 0.5)
            task.wait(0.15)
            applyVelocity(character.HumanoidRootPart, 400, 0.5)
            task.wait(0.15)
            applyVelocity(character.HumanoidRootPart, 350, 0.5)
            task.wait(0.15)
            applyVelocity(character.HumanoidRootPart, 150, 0.5)
            task.wait(0.15)
            applyVelocity(character.HumanoidRootPart, 50, 0.15)
            -- Возвращаем кулдаун в секундах
            return 7
        end
    },
    -- Добавьте другие анимации по шаблону:
    -- ["ANIMATION_ID"] = {
    --     name = "Имя анимации",
    --     handler = function(character)
    --         -- Ваш код здесь
    --         return cooldown -- время кулдауна в секундах
    --     end
    -- }
}

-- Система кулдаунов
local animationCooldowns = {}
local activeAnimations = {}
local DEBUG = false
-- Основная функция проверки анимаций
local function checkAnimations()
    -- Отладочный вывод текущих анимаций
    task.spawn(function()
        if not DEBUG then return end
        while task.wait(0.5) and isAlive do
            local character = plr.Character
            if character and character:FindFirstChild("Humanoid") then
                local humanoid = character.Humanoid
                for i, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                    if animTrack.Animation and animTrack.Animation.AnimationId then
                        print("[Debug] Animation: " .. animTrack.Animation.AnimationId .. " | Track: " .. i)
                    end
                end
            end
        end
    end)
    
    while isAlive do
        local character = plr.Character
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character.Humanoid
            
            -- Получаем текущие анимации
            for _, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                if animTrack.Animation and animTrack.Animation.AnimationId then
                    local animId = string.match(animTrack.Animation.AnimationId, "rbxassetid://(%d+)")
                    
                    -- Если это новая анимация и она есть в нашем списке
                    if animId and animationHandlers[animId] and not activeAnimations[animId] then
                        activeAnimations[animId] = true
                        
                        -- Проверяем кулдаун
                        if not animationCooldowns[animId] or animationCooldowns[animId] < os.time() then
                            local handlerInfo = animationHandlers[animId]
                            print("[Animation Handler] Found animation: " .. handlerInfo.name)
                            
                            -- Выполняем обработчик
                            local cooldown = handlerInfo.handler(character)
                            
                            -- Устанавливаем кулдаун если он есть
                            if cooldown then
                                animationCooldowns[animId] = os.time() + cooldown
                                
                                -- Автоматически снимаем кулдаун через указанное время
                                task.delay(cooldown, function()
                                    if isAlive then
                                        animationCooldowns[animId] = nil
                                    end
                                end)
                            end
                        end
                    end
                end
            end
            
            -- Очищаем отслеживаемые анимации которые перестали играть
            for animId, _ in pairs(activeAnimations) do
                local isPlaying = false
                for _, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                    if animTrack.Animation and animTrack.Animation.AnimationId then
                        local trackId = string.match(animTrack.Animation.AnimationId, "rbxassetid://(%d+)")
                        if trackId == animId then
                            isPlaying = true
                            break
                        end
                    end
                end
                
                if not isPlaying then
                    activeAnimations[animId] = nil
                end
            end
        end
        
        -- Очищаем старые кулдауны
        local currentTime = os.time()
        for animId, cooldownUntil in pairs(animationCooldowns) do
            if cooldownUntil < currentTime then
                animationCooldowns[animId] = nil
            end
        end
        
        task.wait(0.06)
    end
end

-- Функция загрузки персонажа (как в примере)
local function loadCharacter(char)
    if not isAlive then return end
    if not char then return end
    
    -- Переименовываем скиллы в интерфейсе
    renameSkillsInHotbar()
    
    -- Можете добавить другие действия при загрузке персонажа здесь
    print("[Character Loaded] Ready to track animations")
end

-- Подключение событий
registerConnection(game.Players.PlayerRemoving:Connect(function(player)
    if player == plr then
        cleanup()
    end
end))

-- Подключение события добавления персонажа (как в примере)
registerConnection(plr.CharacterAdded:Connect(function(char)
    if isAlive then
        loadCharacter(char)
    end
end))

-- Если персонаж уже есть, загружаем его
if plr.Character and isAlive then
    task.spawn(function()
        if isAlive then
            loadCharacter(plr.Character)
        end
    end)
end

-- Запуск основной функции проверки анимаций
task.spawn(checkAnimations)

-- Уведомление о загрузке
game.StarterGui:SetCore("SendNotification", {
    Title = "Loki Style Loaded",
    Text = "Uhmm is this okay?",
    Duration = 5,
    Button1 = "yes it is bru",
})

print("[Animation Handler] Successfully loaded with ID: " .. SCRIPT_ID)
print("[System] Tracking animations: " .. #table.keys(animationHandlers))
print("[System] Skill renames configured: " .. #table.keys(CFG.renames))

-- Экспорт для отладки (опционально)
return {
    cleanup = cleanup,
    isAlive = function() return isAlive end,
    scriptId = SCRIPT_ID,
    config = CFG,
    animationHandlers = animationHandlers
}