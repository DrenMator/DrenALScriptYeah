-- –°–ò–°–¢–ï–ú–ê –°–ê–ú–û–û–ß–ò–°–¢–ö–ò (–¢–û–ß–ù–ê–Ø –ö–û–ü–ò–Ø –° –ü–†–ò–ú–ï–†–ê)
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local plr = Players.LocalPlayer
local SCRIPT_ID = "Moveset_" .. tick() .. "_" .. math.random(1000, 9999)
local activeConnections = {}
local activeObjects = {}
local isAlive = true

local function cleanup()
    if not isAlive then return end
    isAlive = false
    print("[Animation Handler] Self-destructing: new instance detected")
    
    for _, connection in pairs(activeConnections) do
        if connection then
            pcall(function() connection:Disconnect() end)
        end
    end
    
    for _, object in pairs(activeObjects) do
        if object and object.Parent then
            pcall(function() object:Destroy() end)
        end
    end
    
    activeConnections = {}
    activeObjects = {}
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if terrain then
        local marker = terrain:FindFirstChild("MovesetMarker")
        if marker and marker.Value == SCRIPT_ID then
            marker:Destroy()
        end
    end
end

local function registerConnection(conn)
    if not isAlive then 
        conn:Disconnect()
        return conn 
    end
    table.insert(activeConnections, conn)
    return conn
end

local function registerObject(obj)
    if not isAlive then 
        if obj and obj.Parent then
            obj:Destroy()
        end
        return obj 
    end
    table.insert(activeObjects, obj)
    return obj
end

local function setupMarkerControl()
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if not terrain then return end
    
    for _, child in pairs(terrain:GetChildren()) do
        if child.Name == "MovesetMarker" and child:IsA("StringValue") then
            child:Destroy()
        end
    end
    
    local marker = Instance.new("StringValue")
    marker.Name = "MovesetMarker"
    marker.Value = SCRIPT_ID
    marker.Parent = terrain
    registerObject(marker)
    
    Debris:AddItem(marker, 30)
    
    local connection = terrain.ChildAdded:Connect(function(child)
        if child.Name == "MovesetMarker" and child:IsA("StringValue") then
            if child.Value ~= SCRIPT_ID then
                cleanup()
            end
        end
    end)
    registerConnection(connection)
    
    return marker
end

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –º–∞—Ä–∫–µ—Ä–æ–≤
setupMarkerControl()

-- –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–∞—Ä–∫–µ—Ä–æ–≤ (—Ç–æ—á–Ω–∞—è –∫–æ–ø–∏—è —Å –ø—Ä–∏–º–µ—Ä–∞)
task.spawn(function()
    while isAlive do
        local terrain = workspace:FindFirstChildOfClass("Terrain")
        if terrain then
            local markers = {}
            for _, child in pairs(terrain:GetChildren()) do
                if child.Name == "MovesetMarker" and child:IsA("StringValue") then
                    table.insert(markers, child)
                end
            end
            
            if #markers > 1 then
                local latestTime = 0
                local latestMarker = nil
                
                for _, marker in pairs(markers) do
                    local markerTime = tonumber(string.match(marker.Value, "Moveset_(%d+%.%d+)_")) or 0
                    if markerTime > latestTime then
                        latestTime = markerTime
                        latestMarker = marker
                    end
                end
                
                if latestMarker and latestMarker.Value ~= SCRIPT_ID then
                    cleanup()
                    break
                end
            end
        end
        task.wait(5)
    end
end)

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ (–∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ)
local function applyVelocity(part, speed, duration, direction)
    if not part or not isAlive or not part.Parent then return nil end
    
    -- –ï—Å–ª–∏ direction –Ω–µ —É–∫–∞–∑–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º FORWARD –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    direction = direction or "FORWARD"
    
    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ BodyVelocity
    for _, v in pairs(part:GetChildren()) do
        if v:IsA("BodyVelocity") then
            registerObject(v)
            v:Destroy()
        end
    end

    -- –ü–æ–ª—É—á–∞–µ–º –≤–µ–∫—Ç–æ—Ä—ã –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    local cf = part.CFrame
    local lookVector = cf.LookVector
    local rightVector = cf.RightVector
    local upVector = cf.UpVector
    
    -- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–µ–∫—Ç–æ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏
    local velocityVector = Vector3.new(0, 0, 0)
    
    -- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –≤–µ–∫—Ç–æ—Ä
    local directionMap = {
        -- –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (8 —à—Ç—É–∫)
        ["FORWARD"] = lookVector,
        ["BACKWARD"] = -lookVector,
        ["RIGHT"] = rightVector,
        ["LEFT"] = -rightVector,
        ["UP"] = upVector,
        ["DOWN"] = -upVector,
        
        -- –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (4 —à—Ç—É–∫–∏)
        ["FORWARD_RIGHT"] = (lookVector + rightVector).Unit,
        ["FORWARD_LEFT"] = (lookVector - rightVector).Unit,
        ["BACKWARD_RIGHT"] = (-lookVector + rightVector).Unit,
        ["BACKWARD_LEFT"] = (-lookVector - rightVector).Unit,
        
        -- –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ-–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ (12 —à—Ç—É–∫)
        ["UP_FORWARD"] = (upVector + lookVector).Unit,
        ["UP_BACKWARD"] = (upVector - lookVector).Unit,
        ["UP_RIGHT"] = (upVector + rightVector).Unit,
        ["UP_LEFT"] = (upVector - rightVector).Unit,
        
        ["DOWN_FORWARD"] = (-upVector + lookVector).Unit,
        ["DOWN_BACKWARD"] = (-upVector - lookVector).Unit,
        ["DOWN_RIGHT"] = (-upVector + rightVector).Unit,
        ["DOWN_LEFT"] = (-upVector - rightVector).Unit,
        
        -- –¢—Ä–æ–π–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ (8 —à—Ç—É–∫)
        ["UP_FORWARD_RIGHT"] = (upVector + lookVector + rightVector).Unit,
        ["UP_FORWARD_LEFT"] = (upVector + lookVector - rightVector).Unit,
        ["UP_BACKWARD_RIGHT"] = (upVector - lookVector + rightVector).Unit,
        ["UP_BACKWARD_LEFT"] = (upVector - lookVector - rightVector).Unit,
        
        ["DOWN_FORWARD_RIGHT"] = (-upVector + lookVector + rightVector).Unit,
        ["DOWN_FORWARD_LEFT"] = (-upVector + lookVector - rightVector).Unit,
        ["DOWN_BACKWARD_RIGHT"] = (-upVector - lookVector + rightVector).Unit,
        ["DOWN_BACKWARD_LEFT"] = (-upVector - lookVector - rightVector).Unit,
        
        -- –ö–∞—Å—Ç–æ–º–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–º–µ—Ä—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        ["CAMERA_FORWARD"] = workspace.CurrentCamera.CFrame.LookVector,
        ["CAMERA_RIGHT"] = workspace.CurrentCamera.CFrame.RightVector,
        ["CAMERA_LEFT"] = -workspace.CurrentCamera.CFrame.RightVector,
    }
    
    -- –ü–æ–ª—É—á–∞–µ–º –≤–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    local directionVector = directionMap[direction:upper()]
    
    -- –ï—Å–ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º FORWARD –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
    if not directionVector then
        print("[Warning] Unknown direction: " .. direction .. ", using FORWARD")
        directionVector = lookVector
    end
    
    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ —É—Å–∏–ª–∏–µ
    local maxForceY = 0
    if direction:upper():find("UP") or direction:upper():find("DOWN") or 
       direction == "UP" or direction == "DOWN" then
        maxForceY = 350000
    end
    
    -- –°–æ–∑–¥–∞–µ–º BodyVelocity
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(350000, maxForceY, 350000)
    bv.Velocity = directionVector * speed
    bv.Parent = part
    registerObject(bv)
    
    -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ duration —Å–µ–∫—É–Ω–¥
    task.delay(duration, function()
        if bv and bv.Parent and isAlive then
            bv:Destroy()
        end
    end)
    
    -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    return bv, directionVector
end

-- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –°–ö–ò–õ–õ–û–í (–ö–ê–ö –í –ü–†–ò–ú–ï–†–ï)
local CFG = {
    -- –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Å–∫–∏–ª–ª–æ–≤ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
    renames = {
        ["skill1"] = "Heart Break", 
        ["skill2"] = "Fake Shot",
        ["skill3"] = "Curve Shot",
        ["skill4"] = "KILL",
        ["skill5"] = "Killing Monster",
    }
}

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è —Å–∫–∏–ª–ª–æ–≤ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ (–∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ)
local function renameSkillsInHotbar()
    if not isAlive then return end
    
    task.wait(1) -- –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    
    -- –ñ–¥–µ–º, –ø–æ–∫–∞ –∏–≥—Ä–æ–∫ –Ω–µ –≤—ã–π–¥–µ—Ç –∏–∑ –ª–æ–±–±–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–∫–∞—è –º–µ—Ö–∞–Ω–∏–∫–∞)
    repeat task.wait() until plr.Team and plr.Team.Name ~= "lobby"
    task.wait(0.5)
    
    local hotbar = plr.PlayerGui:WaitForChild("Hotbar", 10)
    if hotbar and isAlive then
        local backpack = hotbar:FindFirstChild("Backpack")
        if backpack then
            local hotbarFrame = backpack:FindFirstChild("Hotbar")
            if hotbarFrame then
                for slotName, newName in pairs(CFG.renames) do
                    local skillFrame = hotbarFrame:FindFirstChild(slotName)
                    if skillFrame then
                        local base = skillFrame:FindFirstChild("Base")
                        if base then
                            local toolName = base:FindFirstChild("ToolName")
                            if toolName then
                                toolName.Text = newName
                                print("[Skill Renamer] Renamed " .. slotName .. " to: " .. newName)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è –º—è—á–∞
local function hasball()
    local character = plr.Character
    if not character then return false end
    return character:FindFirstChild("Ball") ~= nil
end

local function hasult()
    local character = plr.Character
    if not character then return false end
    local flowactive = character:GetAttribute("FlowActive")
    if flowactive == nil then
        return false
    end
    return flowactive == true
end
-- ASSETS HERE
local rin = ReplicatedStorage.Resources.rin
-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–æ–≤
local function sfx(sound, part, volume,TimePos)
    if not isAlive then return nil end
    
    local s = sound:Clone()
    s.Parent = part
    s.Volume = volume or 1
    s.TimePosition = TimePos or 0
    s:Play()
    
    local soundLength = s.TimeLength
    Debris:AddItem(s, soundLength + 15)
    registerObject(s)
    
    return s
end

-- –§—É–Ω–∫—Ü–∏—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ID
local function convert(id)
    return "rbxassetid://" .. id
end

-- –¢–∞–±–ª–∏—Ü–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∞–Ω–∏–º–∞—Ü–∏–π
local animationHandlers = {
    --[[["116181317759538"] = {
        name = "EXAMPLE",
        handler = function(character)
            if not isAlive then return end
            -- –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫
            for i=1,2 do
                applyVelocity(character.HumanoidRootPart, 140, 0.3,"FORWARD_LEFT")
                task.wait(0.2)
                applyVelocity(character.HumanoidRootPart, 140, 0.3,"FORWARD_RIGHT")
                task.wait(0.2)
            end
            applyVelocity(character.HumanoidRootPart, 170, 0.3,"FORWARD")
            task.wait(0.2)
            -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            return 0
        end
    },]]
    --[[["ANIMATION_ID"] = {
        name = "NAME",
        handler = function(character)
            if not isAlive then return end
            local anim = character.Humanoid:LoadAnimation(ANIMATION)
            anim:Play()
            sfx(SOUND, game.SoundService, 10)
            applyVelocity(character.HumanoidRootPart, 170, 0.3,"FORWARD")
            return 0
        end
    },]]
}

-- –°–∏—Å—Ç–µ–º–∞ –∫—É–ª–¥–∞—É–Ω–æ–≤
local animationCooldowns = {}
local activeAnimations = {}
local DEBUG = true
-- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–π
local function checkAnimations()
    -- –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥ —Ç–µ–∫—É—â–∏—Ö –∞–Ω–∏–º–∞—Ü–∏–π
    task.spawn(function()
        if not DEBUG then return end
        while task.wait(0.5) and isAlive do
            local character = plr.Character
            if character and character:FindFirstChild("Humanoid") then
                local humanoid = character.Humanoid
                for i, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                    if animTrack.Animation and animTrack.Animation.AnimationId then
                        print("[Debug] Animation: " .. animTrack.Animation.AnimationId .. " | Track: " .. i)
                    end
                end
            end
        end
    end)
    
    while isAlive do
        local character = plr.Character
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character.Humanoid
            
            -- –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            for _, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                if animTrack.Animation and animTrack.Animation.AnimationId then
                    local animId = string.match(animTrack.Animation.AnimationId, "rbxassetid://(%d+)")
                    
                    -- –ï—Å–ª–∏ —ç—Ç–æ –Ω–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –∏ –æ–Ω–∞ –µ—Å—Ç—å –≤ –Ω–∞—à–µ–º —Å–ø–∏—Å–∫–µ
                    if animId and animationHandlers[animId] and not activeAnimations[animId] then
                        activeAnimations[animId] = true
                        
                        -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω
                        if not animationCooldowns[animId] or animationCooldowns[animId] < os.time() then
                            local handlerInfo = animationHandlers[animId]
                            print("[Animation Handler] Found animation: " .. handlerInfo.name)
                            
                            -- –í—ã–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
                            local cooldown = handlerInfo.handler(character)
                            
                            -- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                            if cooldown then
                                animationCooldowns[animId] = os.time() + cooldown
                                
                                -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–Ω–∏–º–∞–µ–º –∫—É–ª–¥–∞—É–Ω —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
                                task.delay(cooldown, function()
                                    if isAlive then
                                        animationCooldowns[animId] = nil
                                    end
                                end)
                            end
                        end
                    end
                end
            end
            
            -- –û—á–∏—â–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ—Å—Ç–∞–ª–∏ –∏–≥—Ä–∞—Ç—å
            for animId, _ in pairs(activeAnimations) do
                local isPlaying = false
                for _, animTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                    if animTrack.Animation and animTrack.Animation.AnimationId then
                        local trackId = string.match(animTrack.Animation.AnimationId, "rbxassetid://(%d+)")
                        if trackId == animId then
                            isPlaying = true
                            break
                        end
                    end
                end
                
                if not isPlaying then
                    activeAnimations[animId] = nil
                end
            end
        end
        
        -- –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫—É–ª–¥–∞—É–Ω—ã
        local currentTime = os.time()
        for animId, cooldownUntil in pairs(animationCooldowns) do
            if cooldownUntil < currentTime then
                animationCooldowns[animId] = nil
            end
        end
        
        task.wait(0.06)
    end
end

-- –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ)
local function loadCharacter(char)
    if not isAlive then return end
    if not char then return end
    
    -- –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º —Å–∫–∏–ª–ª—ã –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
    renameSkillsInHotbar()
    
    -- –ú–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∑–¥–µ—Å—å
    print("[Character Loaded] Ready to track animations")
end

-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
registerConnection(game.Players.PlayerRemoving:Connect(function(player)
    if player == plr then
        cleanup()
    end
end))

-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ)
registerConnection(plr.CharacterAdded:Connect(function(char)
    if isAlive then
        loadCharacter(char)
    end
end))

-- –ï—Å–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂ —É–∂–µ –µ—Å—Ç—å, –∑–∞–≥—Ä—É–∂–∞–µ–º –µ–≥–æ
if plr.Character and isAlive then
    task.spawn(function()
        if isAlive then
            loadCharacter(plr.Character)
        end
    end)
end

local function Kick(power,root)
    local args = {
        buffer.fromstring("\035\001"),
        {
            {
                "kick",
                power,
                false,
                root.CFrame.LookVector + Vector3.new(0, 0.005, 0) * 90
            }
        }
    }
	game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))
end
-- –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–π
task.spawn(checkAnimations)

local customActive = false

-- –¢–ê–ë–õ–ò–¶–ê –£–°–õ–û–í–ò–ô –î–õ–Ø –°–ö–ò–õ–õ–û–í
local skillBallConditions = {
    [1] = true,
    [2] = true,
    [3] = true,
    [4] = true,
    [5] = nil
}
local skillBallUlts = {
    [1] = nil,
    [2] = nil,
    [3] = nil,
    [4] = false,
    [5] = nil
}

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏—è –º—è—á–∞
local function checkBallCondition(skillNumber)
    local condition = skillBallConditions[skillNumber]
    
    if condition == nil then
        return true  -- –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏, –≤—Å–µ–≥–¥–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ
    elseif condition == true then
        return hasball()  -- —Ç—Ä–µ–±—É–µ—Ç –º—è—á
    elseif condition == false then
        return not hasball()  -- —Ç—Ä–µ–±—É–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –º—è—á–∞
    end
    
    return false
end
local function CheckUlt(skillNumber)
    local condition = skillBallUlts[skillNumber]
    if condition == nil then
        return true  -- –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏, –≤—Å–µ–≥–¥–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ
    elseif condition == true then
        return hasult()  -- —Ç—Ä–µ–±—É–µ—Ç
    elseif condition == false then
        return not hasult()  -- —Ç—Ä–µ–±—É–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ
    end
    
    return false
end
-- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∫—É–ª–¥–∞—É–Ω–æ–≤
local cooldownEndTimes = {}

-- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∫—É–ª–¥–∞—É–Ω-—Ñ—Ä–µ–π–º–æ–≤
local activeCustomFrames = {}

-- –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∫—É–ª–¥–∞—É–Ω-—Ñ—Ä–µ–π–º–∞
local function createCustomCooldownFrame(parentFrame, skillNumber, frameId)
    -- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ñ—Ä–µ–π–º
    local customFrame = Instance.new("Frame")
    customFrame.Name = "CustomCooldown_" .. frameId
    customFrame.BackgroundColor3 = Color3.fromRGB(138, 43, 226) -- –§–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ü–≤–µ—Ç
    customFrame.BackgroundTransparency = 0.3
    customFrame.BorderSizePixel = 0
    customFrame.Size = UDim2.new(1, 0, 1, 0)
    customFrame.Position = UDim2.new(0, 0, 0, 0)
    customFrame.ZIndex = 10
    customFrame.Visible = true
    customFrame.Parent = parentFrame
    
    -- –î–æ–±–∞–≤–ª—è–µ–º —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = customFrame
    
    -- –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(153, 51, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(138, 43, 226))
    })
    gradient.Rotation = 45
    gradient.Parent = customFrame
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ—Ä–µ–π–º–µ
    local frameData = {
        frame = customFrame,
        id = frameId,
        skillNumber = skillNumber,
        created = os.time()
    }
    
    activeCustomFrames[frameId] = frameData
    registerObject(customFrame)
    
    return customFrame, frameData
end

-- –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–∞—Ä—ã—Ö —Ñ—Ä–µ–π–º–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å–∫–∏–ª–ª–∞
local function cleanupOldFramesForSkill(skillNumber)
    for frameId, frameData in pairs(activeCustomFrames) do
        if frameData.skillNumber == skillNumber and frameData.frame and frameData.frame:IsDescendantOf(game) then
            frameData.frame:Destroy()
            activeCustomFrames[frameId] = nil
        end
    end
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—É–ª–¥–∞—É–Ω–∞ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
local function updateCooldownUI(skillNumber, cooldownDuration, frameId)
    if not isAlive then return end
    
    local hotbar = plr.PlayerGui:FindFirstChild("Hotbar")
    if not hotbar then return end
    
    local backpack = hotbar:FindFirstChild("Backpack")
    if not backpack then return end
    
    local hotbarFrame = backpack:FindFirstChild("Hotbar")
    if not hotbarFrame then return end
    
    local skillFrame = hotbarFrame:FindFirstChild("skill" .. skillNumber)
    if not skillFrame then return end
    
    -- –°–æ–∑–¥–∞–µ–º –ù–û–í–´–ô –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ—Ä–µ–π–º
    local customFrame, frameData = createCustomCooldownFrame(skillFrame, skillNumber, frameId)
    
    -- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ñ—Ä–µ–π–º
    customFrame.Size = UDim2.new(1, 0, 1, 0)
    customFrame.Visible = true
    
    -- –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º —Ç–≤–∏–Ω
    local tweenInfo = TweenInfo.new(
        cooldownDuration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out,
        0,
        false,
        0
    )
    
    local tween = game.TweenService:Create(customFrame, tweenInfo, {
        Size = UDim2.new(1, 0, 0, 0)
    })
    
    tween:Play()
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–≤–∏–Ω –≤ –¥–∞–Ω–Ω—ã—Ö —Ñ—Ä–µ–π–º–∞
    frameData.tween = tween
    
    -- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è —Ñ—Ä–µ–π–º–∞
    local function safelyRemoveFrame()
        if not isAlive then return end
        
        -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –µ—â–µ —ç—Ç–æ—Ç —Ñ—Ä–µ–π–º
        if frameData.frame and frameData.frame:IsDescendantOf(game) then
            -- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–≤–∏–Ω, –µ—Å–ª–∏ –æ–Ω –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
            if frameData.tween then
                frameData.tween:Cancel()
                frameData.tween = nil
            end
            
            -- –£–¥–∞–ª—è–µ–º —Ñ—Ä–µ–π–º
            frameData.frame:Destroy()
        end
        
        -- –£–¥–∞–ª—è–µ–º –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ñ—Ä–µ–π–º–æ–≤
        activeCustomFrames[frameId] = nil
    end
    
    -- –ó–∞–ø–ª–∞–Ω–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è –∫—É–ª–¥–∞—É–Ω–∞ + –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–ø–∞—Å
    task.delay(cooldownDuration + 0.1, safelyRemoveFrame)
    
    -- –¢–∞–∫–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è —Ñ—Ä–µ–π–º–∞ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    return safelyRemoveFrame
end

-- –¢–∞–±–ª–∏—Ü–∞ —Å–∫–∏–ª–ª–æ–≤ (—Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –≤—Ä–µ–º—è –∫—É–ª–¥–∞—É–Ω–∞)
local skillFunctions = { --[[
    [SKILL NUMBER] = function(character)
        character.state.stun.Value = true
        
        local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not root then 
            character.state.stun.Value = false
            return 5 
        end
        sfx(fakeshotSound, game.SoundService, 10,0.8)
        local anim = character.Humanoid:LoadAnimation(fakeshotAnim)
        anim:Play()
        anim.TimePosition = 0.8
        applyVelocity(character.HumanoidRootPart, 230, 0.2,"RIGHT")
        task.wait(0.1)
        applyVelocity(character.HumanoidRootPart, 170, 0.2,"RIGHT")
        task.wait(0.1)
        applyVelocity(character.HumanoidRootPart, 135, 0.2,"RIGHT")
        task.wait(0.1)
        applyVelocity(character.HumanoidRootPart, 40, 0.1,"RIGHT")
        task.wait(0.1)
        character.state.stun.Value = false
        
        return 5 -- COOLDOWN
    end,]]
    
    --[[[skillNumb] = function(character)
        character.state.stun.Value = true

        task.wait(0.3)
        character.state.stun.Value = false
        
        return 6 -- cooldown
    end,]]
}

-- –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π
registerConnection(game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if not isAlive then return end
    
    local character = plr.Character
    if not character or not character:FindFirstChild("state") then return end
    
    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä —Å–∫–∏–ª–ª–∞
    local skillNumber
    if input.KeyCode == Enum.KeyCode.One then
        skillNumber = 1
    elseif input.KeyCode == Enum.KeyCode.Two then
        skillNumber = 2
    elseif input.KeyCode == Enum.KeyCode.Three then
        skillNumber = 3
    elseif input.KeyCode == Enum.KeyCode.Four then
        skillNumber = 4
    elseif input.KeyCode == Enum.KeyCode.Five then
        skillNumber = 5
    end
    
    if not skillNumber then return end
    
    -- –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–∫–∏–ª–ª–∞
    local skillFunc = skillFunctions[skillNumber]
    
    -- –ü–†–û–í–ï–†–ö–ê 1: –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏–∏ —Å–∫–∏–ª–ª–∞ –Ω–µ—Ç - –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô –°–ö–ò–õ–õ –†–ê–ë–û–¢–ê–ï–¢
    if not skillFunc then
        print("[Skill System] No function for skill", skillNumber, "- allowing original")
        return  -- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∫–∏–ª–ª —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
    end
    
    -- –ü–†–û–í–ï–†–ö–ê 2: –£—Å–ª–æ–≤–∏–µ –º—è—á–∞
    if not checkBallCondition(skillNumber) then
        -- –£—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ - –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô –°–ö–ò–õ–õ –†–ê–ë–û–¢–ê–ï–¢
        print("[Skill System] No checkBallCondition for skill", skillNumber, "- allowing original")
        return  -- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∫–∏–ª–ª —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
    end

    if not CheckUlt(skillNumber) then
        -- –£—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ - –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô –°–ö–ò–õ–õ –†–ê–ë–û–¢–ê–ï–¢
        print("[Skill System] No skillBallUlts for skill", skillNumber, "- allowing original")
        return  -- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∫–∏–ª–ª —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
    end
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
    local currentTime = os.time()
    if cooldownEndTimes[skillNumber] and cooldownEndTimes[skillNumber] > currentTime then
        print("[Skill System] Skill", skillNumber, "on cooldown - blocking original")
        -- –ë–ª–æ–∫–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∫–∏–ª–ª
        task.spawn(function()
            character.state.stun.Value = true
            task.wait(0.03)
            character.state.stun.Value = false
        end)
        task.wait(0.03)
        return
    end
    
    -- –í–°–ï–ì–î–ê –±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∫–∏–ª–ª, –µ—Å–ª–∏ –¥–æ—à–ª–∏ –¥–æ —ç—Ç–æ–π —Ç–æ—á–∫–∏
    task.spawn(function()
        character.state.stun.Value = true
        task.wait(0.03)
        character.state.stun.Value = false
    end)
    task.wait(0.03)

    -- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–µ—Å–ª–∏ –¥—Ä—É–≥–æ–π —Å–∫—Ä–∏–ø—Ç —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–∏–ª —Å—Ç–∞–Ω)
    if character.state.stun.Value == true then 
        print("[Skill System] Character is stunned - skipping")
        return 
    end
    if customActive then
        return
    end
    
    -- –í–°–ï –ü–†–û–í–ï–†–ö–ò –ü–†–û–ô–î–ï–ù–´ - –ó–ê–ü–£–°–ö–ê–ï–ú –ö–ê–°–¢–û–ú–ù–´–ô –°–ö–ò–õ–õ
    
    -- –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –Ω–æ–≤–æ–≥–æ —Ñ—Ä–µ–π–º–∞
    local frameId = "cd_" .. skillNumber .. "_" .. os.time() .. "_" .. math.random(1000, 9999)
    
    -- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–∞—Å—Ç–æ–º–Ω—ã–π –∫—É–ª–¥–∞—É–Ω-—Ñ—Ä–µ–π–º (—Å–Ω–∞—á–∞–ª–∞ –±–µ–∑ –∑–Ω–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∫—É–ª–¥–∞—É–Ω–∞)
    -- –ë—É–¥–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å –µ–≥–æ –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∫—É–ª–¥–∞—É–Ω–∞
    local hotbar = plr.PlayerGui:FindFirstChild("Hotbar")
    if hotbar then
        local backpack = hotbar:FindFirstChild("Backpack")
        if backpack then
            local hotbarFrame = backpack:FindFirstChild("Hotbar")
            if hotbarFrame then
                local skillFrame = hotbarFrame:FindFirstChild("skill" .. skillNumber)
                if skillFrame then
                    -- –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ñ—Ä–µ–π–º—ã –¥–ª—è —ç—Ç–æ–≥–æ —Å–∫–∏–ª–ª–∞
                    cleanupOldFramesForSkill(skillNumber)
                    
                    -- –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ—Ä–µ–π–º (–±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω –ø–æ–∑–∂–µ)
                    local customFrame, frameData = createCustomCooldownFrame(skillFrame, skillNumber, frameId)
                    customFrame.Size = UDim2.new(1, 0, 1, 0)
                    customFrame.Visible = true
                end
            end
        end
    end
    
    -- –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–∫–∏–ª–ª–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∫–æ—Ä—É—Ç–∏–Ω–µ
    task.spawn(function()
        if not isAlive then return end
        customActive = true
        -- –í—ã–ø–æ–ª–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–∫–∏–ª–ª–∞ –∏ –ø–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –∫—É–ª–¥–∞—É–Ω–∞
        local success, cooldownDuration = pcall(function()
            return skillFunc(character)
        end)
        
        if not success then
            warn("[Skill System] Error in skill", skillNumber,cooldownDuration)
            -- –ü—Ä–∏ –æ—à–∏–±–∫–µ —É–¥–∞–ª—è–µ–º —Ñ—Ä–µ–π–º
            if activeCustomFrames[frameId] and activeCustomFrames[frameId].frame then
                activeCustomFrames[frameId].frame:Destroy()
                activeCustomFrames[frameId] = nil
            end
            return
        end
        
        -- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫—É–ª–¥–∞—É–Ω
        cooldownEndTimes[skillNumber] = os.time() + cooldownDuration
        customActive = false
        -- –¢–µ–ø–µ—Ä—å –æ–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω-—Ñ—Ä–µ–π–º —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º
        if activeCustomFrames[frameId] and activeCustomFrames[frameId].frame then
            local customFrame = activeCustomFrames[frameId].frame
            
            -- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π —Ç–≤–∏–Ω, –µ—Å–ª–∏ –µ—Å—Ç—å
            if activeCustomFrames[frameId].tween then
                activeCustomFrames[frameId].tween:Cancel()
            end
            
            -- –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π —Ç–≤–∏–Ω —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º
            local tweenInfo = TweenInfo.new(
                cooldownDuration,
                Enum.EasingStyle.Linear,
                Enum.EasingDirection.Out,
                0,
                false,
                0
            )
            
            local tween = game.TweenService:Create(customFrame, tweenInfo, {
                Size = UDim2.new(1, 0, 0, 0)
            })
            
            tween:Play()
            activeCustomFrames[frameId].tween = tween
            
            -- –£–¥–∞–ª—è–µ–º —Ñ—Ä–µ–π–º –ø–æ—Å–ª–µ –∫—É–ª–¥–∞—É–Ω–∞
            task.delay(cooldownDuration + 0.1, function()
                if isAlive and activeCustomFrames[frameId] and activeCustomFrames[frameId].frame then
                    activeCustomFrames[frameId].frame:Destroy()
                    activeCustomFrames[frameId] = nil
                end
            end)
        end
        
        -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–Ω–∏–º–∞–µ–º –∫—É–ª–¥–∞—É–Ω —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
        task.delay(cooldownDuration, function()
            if isAlive then
                cooldownEndTimes[skillNumber] = nil
            end
        end)
        
        print("[Skill System] Skill", skillNumber, "executed with cooldown:", cooldownDuration)
    end)
    
    print("[Skill System] Custom skill", skillNumber, "activated with frame ID:", frameId)
end))

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞ –≤—Å–µ—Ö –∫—É–ª–¥–∞—É–Ω–æ–≤
local function resetAllCooldowns()
    for i = 1, 5 do
        cooldownEndTimes[i] = nil
        
        -- –û—á–∏—â–∞–µ–º –≤—Å–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Ñ—Ä–µ–π–º—ã –¥–ª—è —ç—Ç–æ–≥–æ —Å–∫–∏–ª–ª–∞
        cleanupOldFramesForSkill(i)
    end
    print("[Skill System] All cooldowns and custom frames reset")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è/–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∫–∏–ª–ª–∞
local function setSkillFunction(skillNumber, func)
    if skillNumber >= 1 and skillNumber <= 5 then
        skillFunctions[skillNumber] = func
        print("[Skill System] Updated function for skill", skillNumber)
        return true
    end
    return false
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —É—Å–ª–æ–≤–∏—è –º—è—á–∞ –¥–ª—è —Å–∫–∏–ª–ª–∞
local function setSkillBallCondition(skillNumber, condition)
    if skillNumber >= 1 and skillNumber <= 5 then
        skillBallConditions[skillNumber] = condition
        print("[Skill System] Updated ball condition for skill", skillNumber, "to:", condition)
        return true
    end
    return false
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —É—Å–ª–æ–≤–∏—è –º—è—á–∞
local function getSkillBallCondition(skillNumber)
    return skillBallConditions[skillNumber]
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫—É–ª–¥–∞—É–Ω-—Ñ—Ä–µ–π–º–æ–≤ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
local function getActiveCustomFrames()
    local result = {}
    for frameId, frameData in pairs(activeCustomFrames) do
        table.insert(result, {
            id = frameId,
            skillNumber = frameData.skillNumber,
            created = frameData.created,
            alive = frameData.frame and frameData.frame:IsDescendantOf(game)
        })
    end
    return result
end

-- –û–±–Ω–æ–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é cleanup –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤—Å–µ—Ö –∫–∞—Å—Ç–æ–º–Ω—ã—Ö —Ñ—Ä–µ–π–º–æ–≤
local originalCleanup = cleanup
cleanup = function()
    -- –û—á–∏—â–∞–µ–º –≤—Å–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Ñ—Ä–µ–π–º—ã
    for i = 1, 5 do
        cleanupOldFramesForSkill(i)
    end
    
    if originalCleanup then
        originalCleanup()
    end
end

-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
game.StarterGui:SetCore("SendNotification", {
    Title = "Messi Style Loaded",
    Text = "Mess with the best, Die with the rest.",
    Duration = 5,
    Button1 = "ishowspeed gonna take u down broüíÄ",
})

-- –≠–∫—Å–ø–æ—Ä—Ç —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
return {
    cleanup = cleanup,
    isAlive = function() return isAlive end,
    scriptId = SCRIPT_ID,
    config = CFG,
    animationHandlers = animationHandlers,
    skillSystem = {
        resetAllCooldowns = resetAllCooldowns,
        setSkillFunction = setSkillFunction,
        setSkillBallCondition = setSkillBallCondition,
        getSkillBallCondition = getSkillBallCondition,
        cleanupOldFramesForSkill = cleanupOldFramesForSkill,
        getActiveCustomFrames = getActiveCustomFrames,
        getCooldown = function(skillNumber)
            if not cooldownEndTimes[skillNumber] then return 0 end
            local remaining = cooldownEndTimes[skillNumber] - os.time()
            return math.max(0, remaining)
        end,
        hasball = hasball,
        -- –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        debugInfo = function()
            return {
                skillFunctions = table.keys(skillFunctions),
                skillConditions = skillBallConditions,
                cooldownEndTimes = cooldownEndTimes,
                activeFrames = getActiveCustomFrames()
            }
        end
    }
}